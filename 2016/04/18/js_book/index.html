
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="baidu_union_verify" content="d1952c66cf48912e21c18c7c581f382a">
  <meta name="360-site-verification" content="67fbcc5a67f4c65c057315b28fa0b2c8" />
<meta name="google-site-verification" content="2GzxQ0VtXwTSUdmGm6DzcmhTzM_I9QmzCb_pzpMzD88" />
  
    <title>《JavaScript 高级程序设计》读书笔记（一） | Leaf&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="leafxm">
    
    <meta name="description" content="简介  《JavaScript 高级程序设计》第一到五章内容知识点总结。
第一章 JavaScript简介介绍js的历史，主要组成部分以及版本。
主要组成部分有：

ECMAScript，由ECMA-262 定义，提供核心语言功能；
文档对象模型（DOM），提供访问和操作网页内容的方法和接口；
浏览">
    
    
    
    
    <link rel="alternate" href="atom.xml" title="Leaf&#39;s blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            var _bdId ='yxm0530';
             hm.src = "//hm.baidu.com/hm.js?" + _bdId;
             var s = document.getElementsByTagName("script")[0]; 
             s.parentNode.insertBefore(hm, s);
        })();
    </script>
     
</head>

  <body>
    <header>
      <div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Leaf&#39;s blog">Leaf&#39;s blog</a></h1>
				<a class="blog-motto"></a>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
						<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" class="st-default-search-input" maxlength="20" placeholder="Search" />
						</form>
					
					</li>
				</ul>
                            </nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/04/18/js_book/" title="《JavaScript 高级程序设计》读书笔记（一）" itemprop="url">《JavaScript 高级程序设计》读书笔记（一）</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="leafxm">leafxm</a>
    </p>
  <p class="article-time">
    <time datetime="2016-04-17T16:00:00.000Z" itemprop="datePublished">2016-04-18</time>
    更新日期:<time datetime="2016-05-07T17:35:22.026Z" itemprop="dateModified">2016-05-08</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u4E00_u7AE0_JavaScript_u7B80_u4ECB"><span class="toc-number">1.</span> <span class="toc-text">第一章 JavaScript简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u4E8C_u7AE0__u5728HTML__u4E2D_u4F7F_u7528JavaScript"><span class="toc-number">2.</span> <span class="toc-text">第二章 在HTML 中使用JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u6807_u7B7E_u7684_u4F4D_u7F6E_u548C_u5EF6_u8FDF_u811A_u672C_u4E0E_u5F02_u6B65_u811A_u672C"><span class="toc-number">2.1.</span> <span class="toc-text">标签的位置和延迟脚本与异步脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u4E09_u7AE0__u57FA_u672C_u6982_u5FF5"><span class="toc-number">3.</span> <span class="toc-text">第三章 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E25_u683C_u6A21_u5F0F"><span class="toc-number">3.1.</span> <span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u53D8_u91CF"><span class="toc-number">3.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6570_u636E_u7C7B_u578B"><span class="toc-number">3.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u64CD_u4F5C_u7B26"><span class="toc-number">3.4.</span> <span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u8BED_u53E5"><span class="toc-number">3.5.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u51FD_u6570"><span class="toc-number">3.6.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u56DB_u7AE0__u53D8_u91CF_u3001_u4F5C_u7528_u57DF_u548C_u5185_u5B58_u95EE_u9898"><span class="toc-number">4.</span> <span class="toc-text">第四章 变量、作用域和内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5F15_u7528_u7C7B_u578B_u548C_u5F15_u7528_u7C7B_u578B_u7684_u503C"><span class="toc-number">4.1.</span> <span class="toc-text">引用类型和引用类型的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6267_u884C_u73AF_u5883_uFF08execution_context_uFF09_u53CA_u4F5C_u7528_u57DF"><span class="toc-number">4.2.</span> <span class="toc-text">执行环境（execution context）及作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5783_u573E_u6536_u96C6"><span class="toc-number">4.3.</span> <span class="toc-text">垃圾收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u4E94_u7AE0__u5F15_u7528_u7C7B_u578B"><span class="toc-number">5.</span> <span class="toc-text">第五章 引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object__u7C7B_u578B"><span class="toc-number">5.1.</span> <span class="toc-text">Object 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array__u7C7B_u578B"><span class="toc-number">5.2.</span> <span class="toc-text">Array 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date__u7C7B_u578B"><span class="toc-number">5.3.</span> <span class="toc-text">Date 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegExp__u7C7B_u578B"><span class="toc-number">5.4.</span> <span class="toc-text">RegExp 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function__u7C7B_u578B"><span class="toc-number">5.5.</span> <span class="toc-text">Function 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u57FA_u672C_u5305_u88C5_u7C7B_u578B"><span class="toc-number">5.6.</span> <span class="toc-text">基本包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5355_u4F53_u5185_u7F6E_u5BF9_u8C61"><span class="toc-number">5.7.</span> <span class="toc-text">单体内置对象</span></a></li></ol></li></ol>
		</div>
		
		<p><strong>简介</strong>  《JavaScript 高级程序设计》第一到五章内容知识点总结。</p>
<h2 id="u7B2C_u4E00_u7AE0_JavaScript_u7B80_u4ECB"><a href="#u7B2C_u4E00_u7AE0_JavaScript_u7B80_u4ECB" class="headerlink" title="第一章 JavaScript简介"></a>第一章 JavaScript简介</h2><p>介绍js的历史，主要组成部分以及版本。</p>
<p>主要组成部分有：</p>
<ol>
<li>ECMAScript，由ECMA-262 定义，提供核心语言功能；</li>
<li>文档对象模型（DOM），提供访问和操作网页内容的方法和接口；</li>
<li>浏览器对象模型（BOM），提供与浏览器交互的方法和接口。</li>
</ol>
<h2 id="u7B2C_u4E8C_u7AE0__u5728HTML__u4E2D_u4F7F_u7528JavaScript"><a href="#u7B2C_u4E8C_u7AE0__u5728HTML__u4E2D_u4F7F_u7528JavaScript" class="headerlink" title="第二章 在HTML 中使用JavaScript"></a>第二章 在HTML 中使用JavaScript</h2><p>主要介绍如何在HTML中使用js——主要通过<code>&lt;script&gt;</code>元素。</p>
<p>HTML 4.01 为<code>&lt;script&gt;</code>定义了6个属性——<code>async、charset、defer、language（废弃）、src、type</code>。在不存在defer 和async 属性时，浏览器都会按照不同<code>&lt;script&gt;</code>元素在页面中出现的<strong>先后顺序</strong>对它们依次进行解析。而包含在<code>&lt;script&gt;</code>元素<strong>内部</strong>的JavaScript 代码将被从上至下依次解释。</p>
<p>一般使用<code>src</code>表示包含要执行代码的外部文件。和<code>&lt;img&gt;</code>一样，它可以是指向当前HTML页面所在域之外的某个域中的完整URL（<font color="#FF6600">跨域相关</font>）。</p>
<h3 id="u6807_u7B7E_u7684_u4F4D_u7F6E_u548C_u5EF6_u8FDF_u811A_u672C_u4E0E_u5F02_u6B65_u811A_u672C"><a href="#u6807_u7B7E_u7684_u4F4D_u7F6E_u548C_u5EF6_u8FDF_u811A_u672C_u4E0E_u5F02_u6B65_u811A_u672C" class="headerlink" title="标签的位置和延迟脚本与异步脚本"></a>标签的位置和延迟脚本与异步脚本</h3><p>在文档的<code>&lt;head&gt;</code>元素中包含所有JavaScript 文件：这意味着必须等到全部JS 代码都被<strong>下载、解析和执行完成</strong>以后，才能开始呈现页面的内容（浏览器在遇到<code>&lt;body&gt;</code>标签时才开始呈现内容）。为了避免这个问题，现代Web 应用程序一般都把全部JavaScript 引用放在<code>&lt;body&gt;</code>元素中页面内容的后面。</p>
<blockquote>
<p>当浏览器遇到<code>&lt;script&gt;</code>标签时，当前 HTML 页面无从获知 JavaScript 是否会向<code>&lt;p&gt;</code>标签添加内容，或引入其他元素，或甚至移除该标签。因此，这时浏览器会停止处理页面，先执行 JavaScript代码，然后再继续解析和渲染页面。同样的情况也发生在使用 src 属性加载 JavaScript的过程中，浏览器必须先花时间下载外链文件中的代码，然后解析并执行它。在这个过程中，页面渲染和用户交互完全被阻塞了。</p>
</blockquote>
<p>defer：表示脚本可以延迟到<strong>文档完全被解析和显示之后</strong>再执行。<strong>只对外部脚本文件有效</strong>。相当于告诉浏览器立即下载(<font color="#FF6600">当一个带有 defer 属性的 JavaScript 文件下载时，它不会阻塞浏览器的其他进程</font>)，但延迟到浏览器遇到<code>&lt;/html&gt;</code>标签后再执行。HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded 事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。</p>
<p>async：表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本（<font color="#FF6600">下载完成后立即执行</font>）。只对外部脚本文件有效。不保证按照指定它们的先后顺序执行。异步脚本一定会在页面的<strong>load 事件前</strong>执行，但可能会在<strong>DOMContentLoaded 事件触发之前或之后</strong>执行。指定async属性的目的是不让页面等待脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。</p>
<font color="#FF6600">注：页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载；而load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded)。</font>

<h2 id="u7B2C_u4E09_u7AE0__u57FA_u672C_u6982_u5FF5"><a href="#u7B2C_u4E09_u7AE0__u57FA_u672C_u6982_u5FF5" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h2><h3 id="u4E25_u683C_u6A21_u5F0F"><a href="#u4E25_u683C_u6A21_u5F0F" class="headerlink" title="严格模式"></a>严格模式</h3><p>ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为JavaScript 定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：<code>&quot;use strict&quot;;</code></p>
<h3 id="u53D8_u91CF"><a href="#u53D8_u91CF" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript的变量是<strong>松散类型</strong>的，所谓松散类型就是可以用来保存任何类型的数据。用var 操作符定义的变量将成为定义该变量的作用域中的局部变量。省略var 操作符，会创建一个全局变量（给未经声明的变量赋值在<strong>严格模式</strong>下会导致抛出ReferenceError 错误）。（<font color="#FF6600">使用var声明的变量会有变量提升机制，不使用的没有~</font>）</p>
<h3 id="u6570_u636E_u7C7B_u578B"><a href="#u6570_u636E_u7C7B_u578B" class="headerlink" title="数据类型"></a>数据类型</h3><p>ECMAScript 中有5 种简单数据类型（也称为基本数据类型）：<strong>Undefined、Null、Boolean、Number和String</strong>。还有1 种复杂数据类型——Object，Object 本质上是由一组无序的名值对组成的。</p>
<p><strong>typeof 操作符</strong>可以检测给定变量的数据类型。<strong>注意</strong>，调用<code>typeof null</code>会返回”object”，而对函数会返回”function”。</p>
<p>Undefined 类型只有一个值，即特殊的undefined。在使用var 声明变量但未对其加以初始化时，这个变量的值就是undefined。这个值的引入是<strong>为了正式区分空对象指针与未经初始化的变量</strong>。调用没声明的变量会报错，但是可以使用typeof 操作符（对未声明变量只能执行这一项操作）检测其数据类型,会返回undefined。</p>
<p>Null 类型也只有一个值，这个特殊的值是null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用typeof 操作符检测null 值时会返回”object”的原因。实际上，undefined 值是派生自null 值的，因此ECMA-262 规定对它们的相等性测试要返回true。<strong>当要保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null 值</strong>。这样做不仅可以体现null 作为空对象指针的惯例，而且也有助于进一步区分null 和undefined。</p>
<p>Number 类型最基本的数值字面量格式是十进制整数，表示八进制字面值的第一位必须是零（0），如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。八进制字面量在严格模式下是无效的，会导致支持的JavaScript 引擎抛出错误。十六进制字面值的前两位必须是0x。浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。ECMAScript 能够表示的最小数值保存在Number.MIN_VALUE 中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在Number.MAX_VALUE 中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超出JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的Infinity 值。Infinity 不是能够参与计算的数值。要想确定一个数值是不是“有穷”的，可以使用<strong>isFinite()</strong>函数。</p>
<p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在ECMAScript 中，任何数值除以0 会返回NaN，因此不会影响其他代码的执行。NaN 的特点：1.任何涉及NaN 的操作（例如NaN/10）都会返回NaN，2.NaN 与任何值都不相等，包括NaN 本身。<strong>isNaN()</strong>在接收到一个值之后，会尝试将这个值转换为数值，无法转换为数值时会返回true。</p>
<p>有3 个函数可以把非数值转换为数值：<strong>Number()、parseInt()和parseFloat()</strong>。Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。Number()函数的转换规则是其中有如果是null值，返回0，如果是undefined，返回NaN（<font color="#FF6600">null和undefined的又一区别</font>）。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。</p>
<p>ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变<br>某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。要把一个值转换为一个字符串有两种方式——toString()方法和转换类型String()。toString()方法是除了null和undefined之外几乎每个值都有的方法。在不知道要转换的值是不是null 或undefined 的情况下，可以使用转型函数String()，它能够将任何类型的值转换为字符串。</p>
<p>Object 的每个实例都具有下列属性和方法。</p>
<ol>
<li>constructor：保存着用于创建当前对象的函数。</li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在（<font color="#FF6600">不会查找原型链~</font>）。</li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型。</li>
<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in 语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString()：返回对象的字符串表示。</li>
<li>valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。</li>
</ol>
<h3 id="u64CD_u4F5C_u7B26"><a href="#u64CD_u4F5C_u7B26" class="headerlink" title="操作符"></a>操作符</h3><p>操作符的隐式转换规则总结：</p>
<p>一、递增递减运算符(前置、后置)</p>
<ul>
<li>如果包含有效数字字符的字符串（整数或浮点数）时，先将其转换为数字值。字符串变量变成数值变量。返回值的类型是：number类型。</li>
<li>如果不包含有效数字字符串，则会将字符串的值转换为NaN,返回值的类型是：number类型。</li>
<li>如果是boolean类型，则先会把true或者false转换为1或者0，返回值的类型是：number类型。</li>
<li>如果是null类型和underfined类型应用Number转换，分别变成0和NaN,返回值的类型是：number类型。</li>
<li>如果是对象，则先会通过对象的valueOf()方法，进行转换，如果返回的是NaN，调用toString()方法，再进行前面的操作，返回值的类型是：number类型。（注：空数组[]会返回0，再进行加减操作，空对象则会返回NaN）。</li>
</ul>
<p>一元加和减操作符主要用于基本的算术运算，以及转换数据类型。</p>
<p>二、布尔操作符中的隐式转换规律（<font color="#FF6600">只有undefined、null、NaN、0、空字符串会被转换为false，其余都为true。逻辑操作符的运算为短路逻辑运算：前一个条件已经能够得出结果后续条件不再执行！</font>）：</p>
<ul>
<li>逻辑非(!)操作符：首先会通过Boolean()函数将其操作值转换为布尔值，然后求反。</li>
<li>逻辑与(&amp;&amp;)操作符：如果第一个值经过Boolean()函数转换后为true，则返回第二个操作值，否则返回第一个操作值。</li>
<li>逻辑或(||)操作符：如果第一个值经过Boolean()函数转换为false，则返回第二个操作值，否则返回第一个操作值。（<font color="#FF6600">可以用来检测前一个对象是否存在，存在则返回前一个对象，不存在则返回后一个对象，比如事件委托里，var target = e.targte||e.srcElement</font>)</li>
</ul>
<p>三、乘性操作符（乘法、除法和求模）</p>
<p>操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。</p>
<p>四、加性操作符 （加法和减法）</p>
<ul>
<li>如果两个操作符都是数值，则执行常规的算术加\减法操作并返回结果;</li>
<li>如果有一个操作数是NaN，则结果是NaN;</li>
<li>Infinity+Infinity=Infinity,Infinity-Infinity=NaN;</li>
<li>（-Infinity）+（-Infinity）= -Infinity,Infinity-（-Infinity）=Infinity，Infinity+（-Infinity）= NaN；</li>
<li>如果是+0 加\减 +0，则结果是+0；</li>
<li>如果是 -0 加 -0，则结果是-0，如果是-0 减-0，则结果是+0；</li>
<li>如果是+0 加- 0，则结果是+0，如果是+0 减-0，则结果是-0；</li>
</ul>
<p>对于字符串相加：</p>
<ul>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接<br>起来。</li>
<li>如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，<br>然后再应用前面关于字符串的规则。对于undefined 和null，则分别调用String()函数并取得字符<br>串”undefined”和”null”。</li>
</ul>
<p>对于字符串相减：</p>
<ul>
<li>如果有一个操作数是字符串、布尔值、null 或undefined，则先在后台调用Number()函数将<br>其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果<br>就是NaN；</li>
<li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到<br>的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()<br>方法并将得到的字符串转换为数值。</li>
</ul>
<p>五、关系操作符和相等操作符</p>
<ul>
<li>如果两个操作值都是数值，则直接比较大小。</li>
<li>如果两个操作值都是字符串，则字符串进行其Unicode编码进行比较。</li>
<li>如果一个操作值是数值，则另一个值转换为数值进行比较（字符串中的字母会被转换成 NaN）。</li>
<li>如果一个操作值是对象，则调用对象的valueOf()和toString()方法，然后再进行上述比较。</li>
<li>如果一个操作值是布尔值，则将布尔值转换为数值再进行比较。</li>
<li>null 和undefined 是相等的。要比较相等性之前，不能将null 和undefined 转换成其他任何值。</li>
<li><strong>任何操作数（包括NaN）与NaN进行关系比较，结果都是false</strong>。</li>
<li>相等比较时， 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false</li>
</ul>
<p>关于<code>==</code>操作符，winter大大的总结：只要记住 null 只和undefined 相等，有 number 都转 number，有 boolean 也转 number，有 string 都转 string，对象除非指向同一个否则互相不等，NaN 互相不等就可以了。</p>
<h3 id="u8BED_u53E5"><a href="#u8BED_u53E5" class="headerlink" title="语句"></a>语句</h3><p>if，while,do-while,for 语句不赘述。</p>
<p>for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。ECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。</p>
<p>label语句可以在代码中添加标签，以便将将来由break 或continue 语句引用。加标签的语句一般都要与for 语句等循环语句配合使用。</p>
<p>with 语句的作用是将代码的作用域设置到一个特定的对象中。定义with 语句的目的主要是为了简化多次编写同一个对象的工作。</p>
<h3 id="u51FD_u6570"><a href="#u51FD_u6570" class="headerlink" title="函数"></a>函数</h3><p>ECMAScript 函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型，因为参数在内部用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。实际上，在函数体内可以通过arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p>
<p>arguments 对象与数组类似（它并不是Array 的实例）——可以使用方括号语法访问它的每一个元素，使用length 属性来确定传递进来多少个参数。arguments 对象可以与命名参数一起使用，而且它的值永远与对应命名参数的值保持同步，但他们的内存空间是独立的。另外还要记住，如果只传入了一个参数，没有传递值的命名参数将自动被赋予undefined 值，那么为arguments[1]设置的值不会引起没有传递值的命名参数的改变。严格模式对如何使用arguments 对象做出了一些限制：给arguments赋值不会改变命名参数的值，重写arguments 的值会导致语法错误（代码将不会执行）。<strong>ECMAScript 中的所有参数传递的都是值，不可能通过引用传递参数。</strong></p>
<p>ECMAScript 函数不能像传统意义上那样实现重载。因为ECMAScirpt函数没有签名，其参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。如果在ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p>
<h2 id="u7B2C_u56DB_u7AE0__u53D8_u91CF_u3001_u4F5C_u7528_u57DF_u548C_u5185_u5B58_u95EE_u9898"><a href="#u7B2C_u56DB_u7AE0__u53D8_u91CF_u3001_u4F5C_u7528_u57DF_u548C_u5185_u5B58_u95EE_u9898" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h2><p>JavaScript 变量的特征：本质是松散类型，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。</p>
<h3 id="u5F15_u7528_u7C7B_u578B_u548C_u5F15_u7528_u7C7B_u578B_u7684_u503C"><a href="#u5F15_u7528_u7C7B_u578B_u548C_u5F15_u7528_u7C7B_u578B_u7684_u503C" class="headerlink" title="引用类型和引用类型的值"></a>引用类型和引用类型的值</h3><p>基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p>
<p>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。Undefined、Null、Boolean、Number 和String这5 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p>
<p>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的（<strong>实际上，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象</strong>）。</p>
<p>对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。对基本类型，这样的操作不会出错，但是无效。</p>
<p>复制变量时，基本类型会建立一个完全独立的新变量，并把值复制过去。而引用类型复制时也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p>
<p><strong>传递参数</strong>： ECMAScript 中所有函数的参数都是<strong>按值传递</strong>的。也就是说，把函数外部的值复制给函数内部的参数（<strong>参数实际上是函数的局部变量</strong>），就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样，复制的是一个指向对象的指针。对于引用类型，当把参数名指向新的内存空间，再对其做添加属性等操作，不会影响到原来传递的那个对象，所以不是按引用传递参数。</p>
<p>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；引用类型的值是对象，保存在堆内存中；包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</p>
<p>instance of 操作符：根据原型链，检测变量是什么引用类型的实例。</p>
<h3 id="u6267_u884C_u73AF_u5883_uFF08execution_context_uFF09_u53CA_u4F5C_u7528_u57DF"><a href="#u6267_u884C_u73AF_u5883_uFF08execution_context_uFF09_u53CA_u4F5C_u7528_u57DF" class="headerlink" title="执行环境（execution context）及作用域"></a>执行环境（execution context）及作用域</h3><p>执行环境：定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。可参看<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 1. Execution Contexts</a>.</p>
<p>全局执行环境：在Web 浏览器中，全局执行环境被认为是window 对象，因此所有全局变量和函数都是作为window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）</p>
<p>函数执行环境：当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<p>作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即<strong>arguments 对象</strong>（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</p>
<p>延长作用域链：try-catch 语句的catch 块和with 语句。这两个语句都会在作用域链的前端添加一个变量对象。对with 语句来说，会将指定的对象添加到作用域链中。对catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<p>声明变量：使用var或者function声明变量会让变量自动被添加到最接近的环境中。如果初始化变量时没有使用var 声明，该变量会自动被添加到全局环境。在严格模式下，初始化未经声明的变量会导致错误。</p>
<p>在局部作用域中定义了同名变量，而想访问该同名全局变量，可以使用“window.变量名”来访问。</p>
<h3 id="u5783_u573E_u6536_u96C6"><a href="#u5783_u573E_u6536_u96C6" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>标记清除：当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<p>引用计数：循环引用导致内存泄露。</p>
<p>管理内存：最好通过将其值设置为null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。解除一个值的引用并不意味着自动回收该值所占用的内存——解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>
<h2 id="u7B2C_u4E94_u7AE0__u5F15_u7528_u7C7B_u578B"><a href="#u7B2C_u4E94_u7AE0__u5F15_u7528_u7C7B_u578B" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h2><p>引用类型的值（对象）是引用类型的一个实例。在ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<h3 id="Object__u7C7B_u578B"><a href="#Object__u7C7B_u578B" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>创建Object 实例的方式有两种：1.new Object();2.对象字面量。在通过对象字面量定义对象时，实际上不会调用Object 构造函数。使用对象字面量可以向函数传递大量可选参数。</p>
<p>访问对象属性的方法：一般都是点表示法。在JavaScript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以<strong>字符串</strong>的形式放在方括号中。方括号语法的主要优点是可以通过变量来访问属性。（<font color="#FF6600"> person.name 等价于person[“name”]，而person[name]访问的是name变量所存字符串的属性，比如name= “a”,则person[name]等价于person[“a”]以及person.a</font>）如果属性名中包含会导致语法错误的字符（比如空格），或者属性名使用的是关键字或保留字，也可以使用方括号表示法。</p>
<h3 id="Array__u7C7B_u578B"><a href="#Array__u7C7B_u578B" class="headerlink" title="Array 类型"></a>Array 类型</h3><p>特性：与其他语言不同的是，ECMAScript 数组的每一项可以保存任何类型的数据。而且，ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p>
<p>创建数组的基本方式：</p>
<ol>
<li>使用Array 构造函数。如果参数是一个数字，则会按照该数值创建包含给定项数的数组（<font color="#FF6600">数组字面量无法实现这个功能，一个区别~</font>）。可以省略new 操作符。</li>
<li>数组字面量表示法。不会调用Array 构造函数。</li>
</ol>
<p>数组的length属性：不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，即长度值等于最后一项的索引加1。</p>
<p>检测数组：instanceof操作符和Array.isArray()方法</p>
<ol>
<li>对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意的结果。但是instanceof 操作符假定只有一个全局执行环境，如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数，会产生错误判断。</li>
<li>为了解决这个问题，ECMAScript 5新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。<br>（<font color="#FF6600">还可以通过<code>Object.prototype.toString.call(对象名) === &#39;[object Array]&#39;</code>来测试是否是数组。</font>）</li>
</ol>
<p>转换方法：toLocaleString()、toString()和valueOf()方法</p>
<ol>
<li><p>调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以<strong>逗号</strong>分隔的字符串。由于alert()要接收字符串参数，所以它会在后台调用toString()方法，由此会得到与直接调用toString()方法相同的结果。toLocaleString()方法为了取得每一项的值，调用的是每一项的toLocaleString()方法，而不是toString()方法。</p>
</li>
<li><p>数组的toLocaleString()、toString()方法，在默认情况下都会以<strong>逗号</strong>分隔的字符串的形式返回数组项。<strong>而调用valueOf()返回的还是数组。</strong>如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
</li>
<li><p>如果数组中的某一项的值是null 或者undefined，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。</p>
</li>
</ol>
<p>栈方法：ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。</p>
<p>队列方法：结合使用shift()和push()方法，可以像使用队列一样使用数组。同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即<strong>在数组的前端添加项，从数组末端移除项</strong>。</p>
<p>重排序方法：reverse()和sort()，<strong>会改变原数组的排序</strong>。</p>
<p>在默认情况下，sort()方法按升序排列数组项一一即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的<strong>toString()转型方法</strong>，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。 比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。</p>
<p>操作方法： concat(),slice(),splice()方法，前两个不改变原数组，第三个改变原数组。</p>
<ol>
<li>concat()方法用于数组合并，可以基于当前数组中的所有项创建一个新数组（<strong>原数组内容不变</strong>)。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，<strong>最后返回新构建的数组</strong>。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。<font color="#FF6600">数组合并其他方法：<code>Array.prototype.push.apply(array1,array2)</code>,该方法会改变array1为新数组，且返回的是新数组的length。</font></li>
<li>slice()，它能够基于当前数组中的一或多个项创建一个<strong>新数组</strong>。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。参数中有一个<strong>负数</strong>，则用数组长度加上该数来确定相应的位置。如果结束位置小于起始位置，则返回空数组。</li>
<li>splice()方法，可以实现删除、插入、替换功能。<strong>会改变原数组。</strong>三个参数：起始位置、要删除的项数、要插入的项。第三个不传是删除功能，第二个为0是插入功能，都有则替换。splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。</li>
</ol>
<p>位置方法：indexOf()和lastIndexOf()。</p>
<p>这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用<strong>全等</strong>操作符。</p>
<p>迭代方法：都不会修改数组中的包含的值。</p>
<p>ECMAScript 5 为数组定义了5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身（item，index，array）。以下是这5 个迭代方法的作用。</p>
<ul>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。<font color="#FF6600">有返回false的项时就不会再对后面的项检测了，直接返回false。</font></li>
<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。<font color="#FF6600">有返回true的项时就不再对后面的项检测了，直接返回ture。</font></li>
<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true 的项组成的<strong>数组</strong>。</li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。本质上与使用for 循环迭代数组一样。</li>
</ul>
<p>归并方法：</p>
<p>ECMAScript 5 还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传<br>给reduce()和reduceRight()的函数接收4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。如果没有归并基础初始值这个参数，第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项；有的话发生在数组第一项，第一个参数是归并基础初始值，第二个参数是数组第一项。</p>
<p>使用reduce()方法可以执行求数组中所有值之和的操作，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;,<span class="number">1</span>);</span><br><span class="line">alert(sum); <span class="comment">//16</span></span><br></pre></td></tr></table></figure>
<h3 id="Date__u7C7B_u578B"><a href="#Date__u7C7B_u578B" class="headerlink" title="Date 类型"></a>Date 类型</h3><p>ECMAScript 中的Date 类型是在早期Java 中的java.util.Date 类基础上构建的。为此，Date类型使用自UTC（Coordinated Universal Time，国际协调时间）1970 年1 月1 日午夜（零时）开始经过<br>的毫秒数来保存日期。</p>
<p>创建日期对象：new Date();</p>
<p>ECMAScript 5 添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Date 对象分析代码的工作。在不支持它的浏览器中，使用+操作符把Date 对象转换成字符串，也可以达到同样的目的。</p>
<p>Date 类型也重写了toLocaleString()、toString()和valueOf()方法；但这些方法返回的值与其他类型中的方法不同。Date 类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0 到23）表示。具体表示因浏览器而不同。</p>
<p>至于Date 类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。因此，可以<strong>方便使用比较操作符（小于或大于）来比较日期值</strong>。它的getTime() 返回表示日期的毫秒数，与valueOf()方法返回的值相同。</p>
<h3 id="RegExp__u7C7B_u578B"><a href="#RegExp__u7C7B_u578B" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h3><p><code>var expression = / pattern / flags ;</code></p>
<p>模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。</p>
<p>每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。正则表达式的匹配模式支持下列3 个标志：</p>
<ul>
<li>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即<br>停止；</li>
<li>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模<br>式匹配的项。</li>
</ul>
<p>创建正则表达式：字面量以及new RegExp（pattern，flags），构造函数的模式参数是字符串，所有元字符都要经过<strong>双重转义</strong>。两者区别：在ECMAScript 3 中，正则表达式字面量始终会共享同一个RegExp 实例（这样的话第一次匹配成功后，第二次调用就会从上一次匹配的末尾开始），而使用构造函数创建的每一个新RegExp 实例都是一个新实例。而 ECMAScript 5 明确规定，使用正则表达式字面量必须像直接调用RegExp 构造函数一样，每次都创建新的RegExp 实例。</p>
<p>RegExp实例方法：</p>
<ol>
<li><p>exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后<strong>返回包含第一个匹配项信息的数组</strong>，或者在没有匹配项的情况下返回null。返回的数组虽然是Array 的实例，数组长度是匹配项的个数，但包含两个额外的属性：index 和input。其中，index 表示匹配项在字符串中的位置，而input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</p>
<ul>
<li>对于exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回<strong>一个</strong>匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。</li>
</ul>
</li>
<li><p>test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if 语句中。</p>
</li>
</ol>
<p>RegExp 实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。正则表达式的valueOf()方法返回正则表达式本身。</p>
<p>RegExp构造函数的属性：<br><img src="http://7xqrzp.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160426205747.png" alt="RegExp构造函数的属性"></p>
<p>使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息<br>。段属性名需要同方括号来访问。除了上面介绍的几个属性之外，还有多达9 个用于存储捕获组的构造函数属性。访问这些属性的语<br>法是RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在<br>调用exec()或test()方法时，这些属性会被自动填充。</p>
<h3 id="Function__u7C7B_u578B"><a href="#Function__u7C7B_u578B" class="headerlink" title="Function 类型"></a>Function 类型</h3><p>函数实际上是对象。每个函数都是Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函<br>数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p>没有重载：将函数名想象为指针，也有助于理解为什么ECMAScript 中没有函数重载的概念。同名函数会最后定义的覆盖前面定义的。</p>
<p>函数声明和函数表达式的区别：1.是否必须在调用前声明<font color="#FF6600">因为变量提升机制造成。</font>；2.函数表达式可以使用匿名函数，而函数声明不可以。</p>
<p>作为值的函数：因为ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回（<font color="#FF6600">闭包相关</font>)。</p>
<p>函数内部属性：</p>
<ol>
<li>arguments ，是一个<strong>类数组对象</strong>，包含着传入函数中的所有参数。虽然arguments 的主要用途是保存函数参数，但这个对象还有一个名叫callee 的属性，该属性是一个指针，指向拥有这个arguments 对象的函数（该属性可解除函数体内的代码与函数名的耦合状态）。</li>
<li>this,this引用的是函数据以执行的环境对象。具体可参看<a href="http://leafxm.com/2016/04/08/js_this/" target="_blank" rel="external">我的博文</a>。</li>
<li>ECMAScript 5 也规范化了另一个函数对象的属性：caller。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。当函数在严格模式下运行时，访问arguments.callee 会导致错误。ECMAScript 5 还定义了arguments.caller 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller 和函数的caller 属性。</li>
</ol>
<p>函数属性和方法：</p>
<ol>
<li>属性length ：length 属性表示函数<strong>希望</strong>接收的命名参数的个数。</li>
<li>属性prototype ：对于ECMAScript 中的引用类型而言，prototype 是保存它们所有实例方法的真正所在。在ECMAScript 5 中，不可枚举。</li>
<li>方法：每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this 对象的值。apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array 的实例，也可以是arguments 对象。而call()方法，传递给函数的参数必须逐个列举出来。它们真正强大的地方是能够扩充函数赖以运行的作用域。而使用它们来<strong>扩充作用域</strong>的最大好处，就是对象不需要与方法有任何耦合关系。</li>
<li>ECMAScript 5 还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this 值会被绑定到传给bind()函数的值。</li>
</ol>
<h3 id="u57FA_u672C_u5305_u88C5_u7C7B_u578B"><a href="#u57FA_u672C_u5305_u88C5_u7C7B_u578B" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>基本包装类型使得JavaScript 中的基本类型值可以被当作对象来访问。为了便于操作基本类型值，ECMAScript 还提供了3 个特殊的引用类型：Boolean、Number 和String。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而<strong>让我们能够调用一些方法来操作这些数据</strong>。</p>
<p>引用类型与基本包装类型的主要区别就是对象的生存期。使用new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们<strong>不能在运行时为基本类型值添加属性和方法</strong>。</p>
<p>使用new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> number); <span class="comment">//"number"</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure>
</code></pre><p>使用typeof 和instanceof 操作符测试基本类型数值与引用类型数值时，得到的结果完全不同，例如：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">var</span> numberValue = <span class="number">10</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> numberObject); <span class="comment">//"object"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> numberValue); <span class="comment">//"number"</span></span><br><span class="line">alert(numberObject <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line">aler t(numberValue <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</code></pre><p>Boolean 类型：因为布尔表达式中的所有对象都会被转换为true，会造成误解。建议是永远不要使用Boolean 对象。</p>
<p>Number 类型：toFixed()方法会按照指定的小数位返回数值的字符串表示，能够自动舍入；toExponential()方法返回以指数表示法（也称e 表示法）表示的数值的字符串形式。与toFixed()一样，toExponential()也接收一个参数，而且该参数同样也是指定输出结果中的小数位数。不建议直接实例化Number 类型。</p>
<p>String 类型：String 类型的每个实例都有一个length 属性，表示字符串中包含多个字符。</p>
<p>String 类型提供的方法：</p>
<ol>
<li>字符方法charAt()和charCodeAt()，用于访问字符串中特定字符的方法。这两个方法都接收一个<br>参数，即基于0 的字符位置。charAt()返回该位置的字符，而charCodeAt()返回该位置的字符编码。ECMAScript 5 还定义了另一个访问个别字符的方法，在支持此方法的浏览器中，可以使用方括号加数<br>字索引来访问字符串中的特定字符。</li>
<li>字符串操作方法：<ul>
<li>concat()，用于将一或多个字符串拼接起来，<strong>返回拼接得到的新字符串,不会改变原字符串</strong>。</li>
<li>三个基于子字符串创建新字符串的方法slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数slice()和substring()的指定的是子字符串最后一个字符后面的位置（substring()方法会将较小的数作为开始位置，将较大的数作为结束位置），而substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了：其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0，substring()方法会把所有负值参数都转换为0。</li>
</ul>
</li>
<li>字符串位置方法indexOf()和lastIndexOf()：可以从字符串中查找子字符串的方法。</li>
<li>trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</li>
<li>字符串大小写转换方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</li>
<li><p>字符串模式匹配方法：</p>
<ul>
<li>match()，在字符串上调用这个方法，本质上与调用RegExp 的exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp 对象。</li>
<li>search()，这个方法的唯一参数与match()方法的参数相同：由字符串或RegExp 对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式。</li>
<li>replace()，这个方法接受两个参数：第一个参数可以是一个RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中。replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。</li>
<li>split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并<strong>将结果放在一个数组中</strong>。分隔符可以是字符串，也可以是一个RegExp 对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</li>
</ul>
</li>
<li>localeCompare()方法，这个方法比较两个字符串，并返回下列值中的一个：<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；</li>
<li>如果字符串等于字符串参数，则返回0；</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视实现而定）。</li>
</ul>
</li>
<li>fromCharCode()方法，String 构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法charCodeAt()执行的是相反的操作。</li>
<li>HTML方法</li>
</ol>
<h3 id="u5355_u4F53_u5185_u7F6E_u5BF9_u8C61"><a href="#u5355_u4F53_u5185_u7F6E_u5BF9_u8C61" class="headerlink" title="单体内置对象"></a>单体内置对象</h3><p>ECMA-262 对内置对象的定义是：“由ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript 程序执行之前就已经存在了。”意思就是说，开发人员不必显式地实例化内置对象，因为它们已经实例化了。前面我们已经介绍了大多数内置对象，例如Object、Array 和String。ECMA-262 还定义了两个单体内置对象：Global 和Math。</p>
<p>Global 对象：不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全<br>局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global 对象的属性。</p>
<p>Global对象的方法：</p>
<ol>
<li>URI 编码方法，encodeURI()和encodeURIComponent()方法可以对URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的URI 中不能包含某些字符，例如空格。而这两个URI 编码方法就可以对URI 进行编码，它们用特殊的UTF-8 编码替换所有无效的字符，从而让浏览器能够接受和理解。对应的两个方法分别是decodeURI()和<br>decodeURIComponent()。</li>
<li>eval 方法，就像是一个完整的ECMAScript 解析器，它只接受一个参数，即要执行的ECMAScript （或JavaScript）字符串。在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。严格模式下，在外部访问不到eval()中创建的任何变量或函数，同样，在严格模式下，为eval 赋值也会导致错误。</li>
</ol>
<p>Global 对象的属性：<br><img src="http://7xqrzp.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160427143333.png" alt="Global 对象的属性"></p>
<p>window 对象：ECMAScript 虽然没有指出如何直接访问Global 对象，但Web 浏览器都是将这个全局对象作为window 对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。</p>
<p>Math对象：</p>
<ol>
<li>属性<br><img src="http://7xqrzp.com1.z0.glb.clouddn.com/math%E5%B1%9E%E6%80%A7.png" alt="Math属性"></li>
<li>min()和max()方法，用于确定一组数值中的最小值和最大值。这两个方法都可以接收任意多个数值参数。要找到数组中的最大值可以利用apply()方法：<code>var values = [1, 2, 3];var max = Math.max.apply(Math, values);</code></li>
<li>舍入方法：Math.ceil()、Math.floor()和Math.round()，分别为向上取整、向下取整、标准舍入。</li>
<li>random 方法：返回大于等于0 小于1 的一个随机数。</li>
<li>其他方法：<br><img src="http://7xqrzp.com1.z0.glb.clouddn.com/math%E6%96%B9%E6%B3%95.png" alt="Math其他方法"></li>
</ol>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/JavaScript/">JavaScript</a><a href="/tags/读书笔记/">读书笔记</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/总结/">总结</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2016/04/18/js_book/" data-title="《JavaScript 高级程序设计》读书笔记（一） | Leaf&#39;s blog" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/04/21/js_windowObj/" title="获取JS中自定义全局变量">
  <strong>PREVIOUS:</strong><br/>
  <span>
  获取JS中自定义全局变量</span>
</a>
</div>


<div class="next">
<a href="/2016/04/08/js_this/"  title="JavaScript 中的 this 到底指什么？">
 <strong>NEXT:</strong><br/> 
 <span>JavaScript 中的 this 到底指什么？
</span>
</a>
</div>

</nav>

	
<section class="comment">
	
	<div class="ds-thread" data-title="《JavaScript 高级程序设计》读书笔记（一）" data-thread-key="js_book" data-author-key="leafxm" data-url="http://yoursite.com/post/js_book"></div>
	
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u4E00_u7AE0_JavaScript_u7B80_u4ECB"><span class="toc-number">1.</span> <span class="toc-text">第一章 JavaScript简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u4E8C_u7AE0__u5728HTML__u4E2D_u4F7F_u7528JavaScript"><span class="toc-number">2.</span> <span class="toc-text">第二章 在HTML 中使用JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u6807_u7B7E_u7684_u4F4D_u7F6E_u548C_u5EF6_u8FDF_u811A_u672C_u4E0E_u5F02_u6B65_u811A_u672C"><span class="toc-number">2.1.</span> <span class="toc-text">标签的位置和延迟脚本与异步脚本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u4E09_u7AE0__u57FA_u672C_u6982_u5FF5"><span class="toc-number">3.</span> <span class="toc-text">第三章 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u4E25_u683C_u6A21_u5F0F"><span class="toc-number">3.1.</span> <span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u53D8_u91CF"><span class="toc-number">3.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6570_u636E_u7C7B_u578B"><span class="toc-number">3.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u64CD_u4F5C_u7B26"><span class="toc-number">3.4.</span> <span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u8BED_u53E5"><span class="toc-number">3.5.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u51FD_u6570"><span class="toc-number">3.6.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u56DB_u7AE0__u53D8_u91CF_u3001_u4F5C_u7528_u57DF_u548C_u5185_u5B58_u95EE_u9898"><span class="toc-number">4.</span> <span class="toc-text">第四章 变量、作用域和内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5F15_u7528_u7C7B_u578B_u548C_u5F15_u7528_u7C7B_u578B_u7684_u503C"><span class="toc-number">4.1.</span> <span class="toc-text">引用类型和引用类型的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6267_u884C_u73AF_u5883_uFF08execution_context_uFF09_u53CA_u4F5C_u7528_u57DF"><span class="toc-number">4.2.</span> <span class="toc-text">执行环境（execution context）及作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5783_u573E_u6536_u96C6"><span class="toc-number">4.3.</span> <span class="toc-text">垃圾收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7B2C_u4E94_u7AE0__u5F15_u7528_u7C7B_u578B"><span class="toc-number">5.</span> <span class="toc-text">第五章 引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object__u7C7B_u578B"><span class="toc-number">5.1.</span> <span class="toc-text">Object 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array__u7C7B_u578B"><span class="toc-number">5.2.</span> <span class="toc-text">Array 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date__u7C7B_u578B"><span class="toc-number">5.3.</span> <span class="toc-text">Date 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegExp__u7C7B_u578B"><span class="toc-number">5.4.</span> <span class="toc-text">RegExp 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Function__u7C7B_u578B"><span class="toc-number">5.5.</span> <span class="toc-text">Function 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u57FA_u672C_u5305_u88C5_u7C7B_u578B"><span class="toc-number">5.6.</span> <span class="toc-text">基本包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5355_u4F53_u5185_u7F6E_u5BF9_u8C61"><span class="toc-number">5.7.</span> <span class="toc-text">单体内置对象</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">
<div id="authorInfo">
	
		<div class="author-logo" ></div>		
	
	<div class="social-list" class="clearfix">
		
		
		
		<a href="https://github.com/leafxm" target="_blank" title="github"></a>
		
		
		
	</div>
</div>

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/总结/" title="总结">总结<sup>8</sup></a></li>
		
			<li><a href="/categories/教程/" title="教程">教程<sup>2</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/CSS/" title="CSS">CSS<sup>2</sup></a></li>
		
			<li><a href="/tags/HTML/" title="HTML">HTML<sup>1</sup></a></li>
		
			<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>7</sup></a></li>
		
			<li><a href="/tags/github/" title="github">github<sup>1</sup></a></li>
		
			<li><a href="/tags/hexo/" title="hexo">hexo<sup>1</sup></a></li>
		
			<li><a href="/tags/this/" title="this">this<sup>1</sup></a></li>
		
			<li><a href="/tags/事件代理/" title="事件代理">事件代理<sup>1</sup></a></li>
		
			<li><a href="/tags/变量提升/" title="变量提升">变量提升<sup>1</sup></a></li>
		
			<li><a href="/tags/垂直居中/" title="垂直居中">垂直居中<sup>1</sup></a></li>
		
			<li><a href="/tags/基础知识/" title="基础知识">基础知识<sup>1</sup></a></li>
		
			<li><a href="/tags/百度地图/" title="百度地图">百度地图<sup>1</sup></a></li>
		
			<li><a href="/tags/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
		
			<li><a href="/tags/闭包/" title="闭包">闭包<sup>1</sup></a></li>
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
    
            <p class="copyright"> © 2016 
		
		<a href="http://yoursite.com" target="_blank" title="leafxm">leafxm</a>
		
            && Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> && Theme by <a href="http://gengbiao.me" target="_blank" title="coney">coney</a>
		<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
  
  _st('install','VJyggzynWWh5kw3F7Gzq','2.0.0');
</script>
	    </div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"null"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 






<script>
    
        var _bdImg = '4';
    
    window._bd_share_config={
        "common":{
            "bdSnsKey":{

            },
            "bdText":"",
            "bdMini":"2",
            "bdMiniList":[
                "qzone",
                "tsina",
                "weixin",
                "renren",
                "tqq",
                "tieba",
                "douban",
                "sqq",
                "diandian",
                "huaban",
                "youdao",
                "mail",
                "ty",
                "fbook",
                "twi",
                "linkedin",
                "copy",
                "print"
            ],
            "bdPic":"",
            "bdStyle":"0",
            "bdSize":"16"
        },
        "slide":{
            "type":"slide",
            "bdImg":_bdImg,
            "bdPos":"right",
            "bdTop":"350"
        },
        "image":{
            "viewList":[
                "weixin",
                "qzone",
                "tsina",
                "renren",
                "douban",
                "tqq"
            ],
            "viewText":"分享：",
            "viewSize":"16"
        },
        "selectShare":{
            "bdContainerClass":null,
            "bdSelectMiniList":[
                "weixin",
                "qzone",
                "tsina",
                "renren",
                "douban",
                "tqq"
            ]
        }
    };
    with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script>





  </body>
</html>

